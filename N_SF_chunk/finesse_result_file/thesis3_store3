n the system and f is a di.culty parameter. Implementing such a function using the circuit representation required by zero-knowledge proofs would be very cumbersome, due to the non-integer division and the exponentiation necessary to evaluate ¡ã. Finally, the variable di.culty level would require to update the circuit in the ZK-proof as the di.culty changes. 
One of our insights is to exploit the ¡°independent aggregation¡± property of the function for e.ciency purpose, and in fact our solution uses the function ¡ã in a completely black-box way, and thus allows to replace the specifc function above with any other function that satisfes the ¡°independent aggregation¡± property. Thanks to the independent aggregation property, we can let the users commit to their wealth in a bit-by-bit fashion, thus eectively splitting their account into a number of ¡°virtual parties¡± such that party i has wealth 0 or 2i. Then, the values Vi = ¡ã(2i) can be publicly computed (outside of the ZK-proof) and what is left to do for the user is to prove that the output of the VRF (for at least one of the virtual parties i), is less than than the corresponding public value Vi (without revealing which one). 
The solution as described so far allows to prove that one has won the election for a ¡°committed¡± stake but, as described above, the frequency with which an account wins the election reveals information about the user¡¯s wealth as well. Therefore we need to replace the VRF with an ¡°anonymous VRF¡± or AVRF. In a nutshell, an AVRF is a VRF in which there exist multiple verifcation keys for the same secret key, and where it is hard, given two valid proofs for dierent inputs under dierent verifcation keys, to tell whether they were generated by the same secret key or not. We show that it is possible to turn existing e.cient VRF constructions into anonymous VRF with an very small e.ciency loss, and we believe that AVRF is a natural cryptographic primitive which might have further applications. 
2 Preliminaries 
Notation. We use [1,n] to represent the set of numbers {1, 2,...,n}. If A is a randomized algorithm,